<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Taxi Route</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #container {
            display: flex; /* Use flexbox for layout */
        }
        #routeInfo {
            margin-left: 20px; /* Space between map and route info */
            flex: 1; /* Allow route info to take remaining space */
        }
        #map {
            width: 600px; /* Fixed width for the map */
            height: 400px;
        }
        .routeDetail {
            margin-bottom: 15px;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        h3 {
            margin-top: 0;
        }
        .sectionDetail, .guideDetail {
            margin-top: 10px;
        }
    </style>
</head>
<body>
<h1>Car Taxi Route</h1>
<div id="container">
    <div id="map"></div> <!-- Map display -->
    <div id="routeInfo"></div> <!-- Route information display -->
</div>

<script src="https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=g24wojyn1l"></script>
<script>
    let polylines = []; // Array to hold polylines
    let markers = [];   // Array to hold markers
    const urlParams = new URLSearchParams(window.location.search);
    const planId = urlParams.get('planId');

    // Initialize Naver Map
    let map = new naver.maps.Map("map", {
        center: new naver.maps.LatLng(37.5665, 126.9780), // Default coordinates (Seoul)
        zoom: 12
    });

    // JWT token from local storage or cookies
    const jwt = localStorage.getItem('token');

    let routeData; // Declare routeData as a global variable

    fetch(`/api/route-car-taxi/${planId}`, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${jwt}`
        }
    })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            routeData = data; // Assign the fetched data to the global variable
            displayRouteInfo(routeData);
        })
        .catch(error => {
            console.error("Fetch error:", error);
        });

    function displayRouteInfo(data) {
        const routeInfoDiv = document.getElementById('routeInfo');
        routeInfoDiv.innerHTML = '';

        if (data.code === 0 && data.route && data.route.traoptimal) {
            data.route.traoptimal.forEach((optimalRoute, index) => {
                const summary = optimalRoute.summary;
                const routeDetail = document.createElement('div');
                routeDetail.className = 'routeDetail';

                // Display summary information
                routeDetail.innerHTML = `
                    <h3>Route ${index + 1}</h3>
                    <p><strong>Distance:</strong> ${(summary.distance / 1000).toFixed(2)} km</p>
                    <p><strong>Duration:</strong> ${Math.round(summary.duration / 1000 / 60)} minutes</p>
                    <p><strong>Toll Fare:</strong> ${summary.tollFare} won</p>
                    <p><strong>Taxi Fare:</strong> ${summary.taxiFare} won</p>
                    <p><strong>Fuel Price:</strong> ${summary.fuelPrice} won</p>
                    <button onclick="showPathOnMap(${index})">Show on Map</button>
                `;

                routeInfoDiv.appendChild(routeDetail);
            });
        } else {
            routeInfoDiv.innerHTML = `<p>Error: ${data.message || "No route data available."}</p>`;
        }
    }

    function showPathOnMap(routeIndex) {
        // Remove existing paths from the map
        removePolylines();
        removeMarkers();

        // Retrieve path data for the selected route
        const selectedRoute = routeData.route.traoptimal[routeIndex];
        const pathData = selectedRoute.path;
        const path = pathData.map(coords => new naver.maps.LatLng(coords[1], coords[0])); // Convert to LatLng format

        // Draw the path on the map
        const polyline = new naver.maps.Polyline({
            map: map,
            path: path,
            strokeColor: '#FF0000',
            strokeWeight: 5,
        });
        polylines.push(polyline); // Store polyline reference

        // Check for summary existence
        if (selectedRoute.summary) {
            // Define start and goal locations
            const startLocation = selectedRoute.summary.start?.location; // Safe access with optional chaining
            const goalLocation = selectedRoute.summary.goal?.location; // Safe access with optional chaining

            // Check if startLocation and goalLocation are defined
            if (startLocation && goalLocation) {
                // Add markers for the start and goal locations
                addMarker(startLocation, 'Start Point', 'green', map);
                addMarker(goalLocation, 'Goal Point', 'red', map);

                // Adjust the map to fit the path
                fitMapToPath(path, startLocation, goalLocation);
                displayGuideInfo(selectedRoute.guide);
            } else {
                console.error("Start or goal location is undefined");
            }
        } else {
            console.error("Route summary is undefined");
        }
    }

    function displayGuideInfo(guide) {
        const routeInfoDiv = document.getElementById('routeInfo');
        const guideDetailDiv = document.createElement('div');
        guideDetailDiv.className = 'guideDetail';
        guideDetailDiv.innerHTML = `<h4>Guide Instructions:</h4>`;

        guide.forEach((step, index) => {
            // Add marker for each step, assuming step.location is available
            if (step.location) {
                addMarker(step.location, step.instructions, 'blue', map); // Use blue markers for instructions
            }

            guideDetailDiv.innerHTML += `
            <p><strong>Instruction ${index + 1}:</strong> ${step.instructions}</p>
            <p><strong>Distance to Next Step:</strong> ${step.distance} m</p>
            <p><strong>Duration to Next Step:</strong> ${(step.duration / 1000 / 60).toFixed(1)} minutes</p>
            <hr />
        `;
        });

        routeInfoDiv.appendChild(guideDetailDiv);
    }


    // Function to add a marker to the map
    function addMarker(location, title, color, map) {
        const marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(location[1], location[0]), // lat, lng
            map: map,
            title: title,
            icon: {
                content: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%;"></div>`
            }
        });
        markers.push(marker); // Store marker reference
    }

    // Function to remove existing polylines from the map
    function removePolylines() {
        polylines.forEach(polyline => polyline.setMap(null));
        polylines = []; // Clear the array
    }

    // Function to remove existing markers from the map
    function removeMarkers() {
        markers.forEach(marker => marker.setMap(null));
        markers = []; // Clear the array
    }

    // Function to fit the map to the given path and locations
    function fitMapToPath(path, startLocation, goalLocation) {
        const bounds = new naver.maps.LatLngBounds();

        // Extend bounds for each point in the path
        path.forEach(point => bounds.extend(point));
        bounds.extend(new naver.maps.LatLng(startLocation[1], startLocation[0])); // Include start point
        bounds.extend(new naver.maps.LatLng(goalLocation[1], goalLocation[0])); // Include goal point

        // Fit the map to the new bounds
        map.fitBounds(bounds);
    }

</script>
</body>
</html>
